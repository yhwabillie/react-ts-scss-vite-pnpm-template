import React, {
  forwardRef,
  useCallback,
  useEffect,
  useLayoutEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import clsx from 'clsx';
import styles from '@/components/ui/molecules/Combobox/Combobox.module.scss';
import Icon from '@/components/ui/atoms/Icon/Icon';
import IconButton from '@/components/ui/molecules/IconButton/IconButton';
import OptionListPortal from '@/components/ui/molecules/OptionListPortal/OptionListPortal';
import type { PortalPosition } from '../OptionListPortal/OptionListPortal';
import type { OptionListProps } from '../OptionList/OptionList';
import type { OptionItemProps } from '../OptionItem/OptionItem';

type BaseProps = {
  variant: 'solid' | 'soft' | 'outline' | 'ghost';
  color:
    | 'primary'
    | 'secondary'
    | 'tertiary'
    | 'brand'
    | 'brand-sub'
    | 'success'
    | 'warning'
    | 'danger';
  size: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
  id?: string;
  className?: string;
  required?: boolean;
  disabled?: boolean;
  ariaControls?: string;
  ariaLabelledBy?: string;
  value: string;
  placeholder?: string;
  children: React.ReactNode;
  onValueChange?: (value: string) => void;
};

type ComboboxProps = BaseProps & Omit<React.HTMLAttributes<HTMLInputElement>, keyof BaseProps>;

const Combobox = forwardRef<HTMLInputElement, ComboboxProps>(
  (
    {
      variant,
      color,
      size,
      id,
      className,
      required,
      disabled,
      ariaControls,
      ariaLabelledBy,
      value,
      placeholder,
      children,
      onValueChange,
    },
    ref,
  ) => {
    const [isOpen, setIsOpen] = useState(false);
    // [ìˆ˜ì •] focusedIndexëŠ” ì´ì œ filteredOptions ë‚´ì˜ ì¸ë±ìŠ¤ë¥¼ ê°€ë¦¬í‚µë‹ˆë‹¤.
    const [focusedIndex, setFocusedIndex] = useState<number | null>(null);
    const [positioned, setPositioned] = useState(false);
    const [portalPos, setPortalPos] = useState<PortalPosition | null>(null);

    const portalRef = useRef<HTMLDivElement | null>(null);
    const containerRef = useRef<HTMLDivElement>(null);
    // [ì‚­ì œ] optionRefsëŠ” ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì£¼ì„ ì²˜ë¦¬í•˜ê±°ë‚˜ ì œê±° (ìŠ¤í¬ë¡¤ ë¡œì§ì„ filteredOptionRefsê°€ ëŒ€ì²´)
    // const optionRefs = useRef<HTMLLIElement[]>([]);

    // -----------------------------
    // custom-input í¬ì»¤ìŠ¤ ì œì–´ ref
    // -----------------------------
    const customInputRef = React.useRef<HTMLDivElement>(null);

    // -----------------------------
    // ì„ íƒëœ ì˜µì…˜ ìŠ¤í¬ë¡¤ ì´ë™ (í•œ ë²ˆë§Œ)
    // -----------------------------
    const hasScrolledRef = useRef(false);

    // --------------------------------------------
    // OptionList + OptionItem (childrenì—ì„œ ì¶”ì¶œ)
    // --------------------------------------------
    const optionList = React.Children.toArray(children).find(child =>
      React.isValidElement(child),
    ) as React.ReactElement<OptionListProps>;
    if (!optionList) return null;

    const optionItemArr = React.Children.toArray(optionList.props.children).filter(child =>
      React.isValidElement(child),
    ) as React.ReactElement<OptionItemProps>[];

    // -----------------------------
    // ParsedOptions (ì „ì²´ ì˜µì…˜)
    // -----------------------------
    const parsedOptions = useMemo(() => {
      return optionItemArr.map((item, idx) => {
        const index = idx;
        const id = item.props.id;
        const value = item.props.value;
        const selected = item.props.selected;
        const disabled = item.props['aria-disabled'];

        return {
          index, // ì „ì²´ ì˜µì…˜ ë‚´ ì¸ë±ìŠ¤
          id,
          value,
          selected,
          disabled,
        };
      });
    }, [optionItemArr]);

    // ---------------------------------------------------------------------------------------
    // selectedId/selectedValue ìƒíƒœ ê´€ë¦¬ (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
    // ---------------------------------------------------------------------------------------
    const [selectedId, setSelectedId] = useState<string>(() => {
      const selectedOption = parsedOptions.find(opt => opt.selected && !opt.disabled);
      if (selectedOption) return selectedOption.id;

      return '';
    });

    const [selectedValue, setSelectedValue] = useState<string>(
      parsedOptions.find(opt => opt.selected)?.value ?? '',
    );

    // -----------------------------
    // OptionList ì—´ê¸° ì§ì „ ê°’ ì €ì¥
    // -----------------------------
    const [prevSelectedValue, setPrevSelectedValue] = useState(selectedValue);

    // -----------------------------
    // handleSelect (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
    // -----------------------------
    const handleSelect = useCallback(
      (id: string, value: string) => {
        setSelectedId(id);
        setSelectedValue(value);
        setPrevSelectedValue(value);
        onValueChange?.(value);
        setIsOpen(false);
        setFocusedIndex(null); // ì„ íƒ ì™„ë£Œ ì‹œ í¬ì»¤ìŠ¤ ì¸ë±ìŠ¤ ì´ˆê¸°í™”
      },
      [onValueChange],
    );

    // -----------------------------
    // handleBlur [ìœ íš¨ì„± ê²€ì‚¬ ë¡œì§ì´ ì´ë¯¸ ì ìš©ë˜ì–´ ìˆìŒ]
    // -----------------------------
    const handleBlur = useCallback(
      (e: React.FocusEvent<HTMLInputElement>) => {
        const nextFocusedElement = e.relatedTarget as Node | null;

        // í¬ì»¤ìŠ¤ê°€ ì½¤ë³´ë°•ìŠ¤ ë‚´ë¶€ë¡œ ì´ë™í•˜ì§€ ì•ŠëŠ” ê²½ìš°ì—ë§Œ ê°’ ìœ íš¨ì„± ê²€ì‚¬ ì‹¤í–‰
        const isMovingInsideCombobox =
          (containerRef.current && containerRef.current.contains(nextFocusedElement)) ||
          (portalRef.current && portalRef.current.contains(nextFocusedElement));

        if (!isMovingInsideCombobox) {
          setIsOpen(false);
          setFocusedIndex(null);

          // ğŸš¨ [í•µì‹¬ ë¡œì§ í™•ì¸]: ìš”ì²­í•˜ì‹  ìœ íš¨ì„± ê²€ì‚¬ ë° ì´ˆê¸°í™”
          const isValueMatchedInOptions = parsedOptions.some(opt => opt.value === selectedValue);

          if (!isValueMatchedInOptions) {
            // í˜„ì¬ ì…ë ¥ëœ ê°’ì´ ìœ íš¨í•œ ì˜µì…˜ ê°’ê³¼ ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ì´ˆê¸°í™” (ë¹ˆ ë¬¸ìì—´)
            setSelectedValue('');
            setSelectedId('');
          } else {
            // í˜„ì¬ ì…ë ¥ëœ ê°’ì´ ìœ íš¨í•œ ì˜µì…˜ ê°’ê³¼ ì¼ì¹˜í•˜ë©´ í•´ë‹¹ ê°’ì„ ìœ ì§€
            const matchedOption = parsedOptions.find(opt => opt.value === selectedValue);
            if (matchedOption) {
              setSelectedId(matchedOption.id);
            }
          }
        }
      },
      [parsedOptions, selectedValue, setSelectedValue, setSelectedId, setIsOpen, setFocusedIndex],
    );

    // -----------------------------
    // ì…ë ¥ê°’(selectedValue)ì— ë”°ë¼ ì˜µì…˜ í•„í„°ë§ [ìµœì¢… ìˆ˜ì •]
    // -----------------------------
    const filteredOptions = useMemo(() => {
      // 1. ì„ íƒëœ ê°’ì´ ì—†ê±°ë‚˜, í˜„ì¬ input ê°’ì´ ì´ë¯¸ ì„ íƒëœ ì˜µì…˜ì˜ ê°’ê³¼ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ê²½ìš°
      if (
        !selectedValue ||
        parsedOptions.find(opt => opt.value === selectedValue && opt.id === selectedId)
      ) {
        // ì „ì²´ ëª©ë¡ ë°˜í™˜
        return parsedOptions;
      }

      // 2. ê²€ìƒ‰ ì¤‘ì´ê±°ë‚˜, input ê°’ì´ ì„ íƒëœ ê°’ê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠëŠ” ê²½ìš° (ì¦‰, íƒ€ì´í•‘ ì¤‘ì¸ ìƒí™©)
      return parsedOptions.filter(
        opt =>
          // ğŸš¨ [í•µì‹¬ ìˆ˜ì •]: disabledê°€ ì•„ë‹Œ í•­ëª©ë§Œ í¬í•¨í•˜ê³ ,
          !opt.disabled &&
          // ê²€ìƒ‰ì–´ì™€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
          opt.value.toLowerCase().includes(selectedValue.toLowerCase()),
      );
    }, [parsedOptions, selectedValue, selectedId]);

    // [ì¶”ê°€] filteredOptionsê°€ ë³€ê²½ë˜ë©´ focusedIndex ì´ˆê¸°í™”
    useEffect(() => {
      if (isOpen) {
        // ê²€ìƒ‰ ê²°ê³¼ê°€ ë³€ê²½ë˜ë©´ í¬ì»¤ìŠ¤ ì´ˆê¸°í™” (ì‚¬ìš©ìê°€ ìƒˆë¡œìš´ ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•  ë•Œ)
        setFocusedIndex(null);
      }
    }, [filteredOptions.length, isOpen]);

    // -----------------------------
    // handleKeyDown [ìµœì¢… ìˆ˜ì •: preventDefault ìœ„ì¹˜ ë³€ê²½]
    // -----------------------------
    const handleKeyDown = useCallback(
      <T extends HTMLElement>(e: React.KeyboardEvent<T>) => {
        e.stopPropagation();
        // ğŸš¨ [ì œê±°]: ëª¨ë“  í‚¤ ì…ë ¥ì— ëŒ€í•œ e.preventDefault()ë¥¼ ì—¬ê¸°ì„œ ì œê±°í•©ë‹ˆë‹¤.
        // ì¼ë°˜ì ì¸ ë¬¸ì ì…ë ¥ì€ í—ˆìš©í•´ì•¼ í•©ë‹ˆë‹¤.

        const isNavigationKey = ['Enter', ' ', 'ArrowDown', 'ArrowUp', 'Escape'].includes(e.key);

        if (isNavigationKey) {
          // íƒìƒ‰ í‚¤ì— ëŒ€í•´ì„œë§Œ ê¸°ë³¸ ë™ì‘ì„ ë§‰ìŠµë‹ˆë‹¤. (ìŠ¤í¬ë¡¤, í¼ ì œì¶œ ë“±ì„ ë°©ì§€)
          e.preventDefault();
        }

        // í˜„ì¬ í¬ì»¤ìŠ¤ ì¸ë±ìŠ¤ë¥¼ ì§€ì—­ ë³€ìˆ˜ë¡œ ê°€ì ¸ì™€ì„œ ë‹¤ìŒ ê°’ì„ ê³„ì‚°í•˜ëŠ” ë° ì‚¬ìš©
        let nextFocusedIndex = focusedIndex;

        if (!isOpen && isNavigationKey) {
          setIsOpen(true);

          // í¬ì»¤ìŠ¤ ì´ˆê¸°ê°’ ê³„ì‚°
          if (e.key === 'ArrowDown') {
            nextFocusedIndex = null; // ë‹¤ìŒ ArrowDownì—ì„œ ì²« ì˜µì…˜ë¶€í„° ì‹œì‘
          } else {
            // ì´ë¯¸ ì„ íƒëœ ê°’ì´ ìˆë‹¤ë©´ ê·¸ ì¸ë±ìŠ¤ë¥¼ ìš°ì„ 
            let focusIdx = filteredOptions.findIndex(opt => opt.id === selectedId && !opt.disabled);
            if (focusIdx === -1) {
              // ì„ íƒëœ ê°’ ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ ìœ íš¨ ì˜µì…˜
              focusIdx = filteredOptions.findIndex(opt => !opt.disabled);
            }
            nextFocusedIndex = focusIdx !== -1 ? focusIdx : null;
          }

          setFocusedIndex(nextFocusedIndex);
        }

        // ğŸš¨ ì£¼ì˜: setTimeout ë‚´ë¶€ì—ì„œëŠ” e.preventDefault()ë¥¼ í˜¸ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
        // (ì´ë²¤íŠ¸ê°€ ì´ë¯¸ ì²˜ë¦¬ë˜ì—ˆìœ¼ë¯€ë¡œ) ë”°ë¼ì„œ ìœ„ì— isNavigationKeyë¥¼ ì‚¬ìš©í•˜ì—¬ ì²˜ë¦¬í•©ë‹ˆë‹¤.

        if (!isOpen) {
          // ì½¤ë³´ë°•ìŠ¤ê°€ ë‹«íŒ ìƒíƒœ (ëª©ë¡ ì—´ê¸°)
          if (isNavigationKey) {
            // isNavigationKeyë¡œ í†µí•©
            setIsOpen(true);

            // ArrowDown: ëª©ë¡ë§Œ ì—´ê³ , ë‹¤ìŒ í‚¤ ì…ë ¥(ArrowDown)ì—ì„œ 0ìœ¼ë¡œ ì‹œì‘í•˜ê²Œ null ìœ ì§€
            if (e.key === 'ArrowDown') {
              nextFocusedIndex = null;
            } else {
              // Enter/Space: ì„ íƒëœ í•­ëª©ì´ë‚˜ ì²« í•­ëª©ìœ¼ë¡œ í¬ì»¤ìŠ¤ë¥¼ ì´ë™
              let focusIdx = filteredOptions.findIndex(
                opt => opt.id === selectedId && !opt.disabled,
              );

              // ğŸš¨ 1. ì„ íƒëœ í•­ëª©(selectedId)ì´ ìˆê³  ë¹„í™œì„±í™”(disabled)ë˜ì§€ ì•Šì•˜ë‹¤ë©´,
              //    focusIdxëŠ” í•´ë‹¹ í•­ëª©ì˜ ì¸ë±ìŠ¤ë¥¼ ê°–ê²Œ ë©ë‹ˆë‹¤. (ìµœìš°ì„  ìˆœìœ„)

              if (focusIdx === -1) {
                // 2. ì„ íƒëœ í•­ëª©ì´ ì—†ë‹¤ë©´, í•„í„°ë§ëœ ì˜µì…˜ ì¤‘ ê°€ì¥ ì²˜ìŒ ë‚˜íƒ€ë‚˜ëŠ”
                //    ë¹„í™œì„±í™”ë˜ì§€ ì•Šì€ í•­ëª©ì„ ì°¾ìŠµë‹ˆë‹¤.
                focusIdx = filteredOptions.findIndex(opt => !opt.disabled);
              }
              nextFocusedIndex = focusIdx !== -1 ? focusIdx : null;
            }

            setFocusedIndex(nextFocusedIndex);
          }
        } else {
          // ì½¤ë³´ë°•ìŠ¤ê°€ ì—´ë¦° ìƒíƒœ
          if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
            // í¬ì»¤ìŠ¤ ì´ë™ ë¡œì§ (ì´ì „ê³¼ ë™ì¼)
            if (filteredOptions.length === 0) {
              nextFocusedIndex = null;
            } else {
              // ... (ArrowDown, ArrowUp ë¡œì§ ìœ ì§€) ...
              if (e.key === 'ArrowDown') {
                if (nextFocusedIndex === null) {
                  // ë¦¬ìŠ¤íŠ¸ ì—´ìë§ˆì í¬ì»¤ìŠ¤ê°€ ì—†ëŠ” ìƒíƒœë¼ë©´ selectedId ë˜ëŠ” ì²« ìœ íš¨ ì˜µì…˜
                  nextFocusedIndex = filteredOptions.findIndex(
                    opt => opt.id === selectedId && !opt.disabled,
                  );
                  if (nextFocusedIndex === -1)
                    nextFocusedIndex = filteredOptions.findIndex(opt => !opt.disabled);
                } else {
                  let i = nextFocusedIndex + 1;
                  while (i < filteredOptions.length && filteredOptions[i].disabled) i++;
                  if (i < filteredOptions.length) nextFocusedIndex = i;
                }
                setFocusedIndex(nextFocusedIndex);
              } else if (e.key === 'ArrowUp') {
                if (nextFocusedIndex === null) {
                  // ë¦¬ìŠ¤íŠ¸ ì—´ìë§ˆì í¬ì»¤ìŠ¤ê°€ ì—†ëŠ” ìƒíƒœë¼ë©´ selectedId ë˜ëŠ” ë§ˆì§€ë§‰ ìœ íš¨ ì˜µì…˜
                  nextFocusedIndex = filteredOptions.findIndex(
                    opt => opt.id === selectedId && !opt.disabled,
                  );
                  if (nextFocusedIndex === -1) {
                    let lastIdx = filteredOptions.length - 1;
                    while (lastIdx >= 0 && filteredOptions[lastIdx].disabled) lastIdx--;
                    nextFocusedIndex = lastIdx >= 0 ? lastIdx : null;
                  }
                } else {
                  let i = nextFocusedIndex - 1;
                  while (i >= 0 && filteredOptions[i].disabled) i--;
                  if (i >= 0) nextFocusedIndex = i;
                }
                setFocusedIndex(nextFocusedIndex);
              }
            }

            setFocusedIndex(nextFocusedIndex); // ìµœì¢… ê³„ì‚°ëœ ê°’ í•œ ë²ˆë§Œ ì—…ë°ì´íŠ¸
          } else if (e.key === 'Enter' || e.key === ' ') {
            // ì˜µì…˜ ì„ íƒ ë¡œì§ (ì´ì „ê³¼ ë™ì¼)
            if (
              focusedIndex !== null &&
              focusedIndex >= 0 &&
              focusedIndex < filteredOptions.length
            ) {
              const selectedOption = filteredOptions[focusedIndex];
              if (!selectedOption.disabled) {
                handleSelect(selectedOption.id, selectedOption.value);
                customInputRef.current?.focus();
              }

              // ğŸš¨ [í•µì‹¬ ìˆ˜ì •]: custom-inputì˜ ì²« ë²ˆì§¸ ìì‹ ìš”ì†Œ(input)ì— í¬ì»¤ìŠ¤ ë°˜í™˜
              const inputElement = customInputRef.current?.firstChild as
                | HTMLInputElement
                | undefined;
              if (inputElement) {
                inputElement.focus();
                setIsOpen(false);
              }
            }
          } else if (e.key === 'Escape') {
            // Escape: ë‹«ê³  í¬ì»¤ìŠ¤ë¥¼ inputìœ¼ë¡œ ì´ë™í•˜ë©°, í•„ìš”ì‹œ ê°’ ë³µì› (ì´ì „ê³¼ ë™ì¼)

            // 3. ğŸš¨ [ìƒˆë¡œìš´ ê°’ ë³µì›/ìœ ì§€ ë¡œì§]
            // í˜„ì¬ ì…ë ¥ëœ selectedValueê°€ ì „ì²´ ì˜µì…˜ ëª©ë¡ì— ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
            const isValueMatchedInOptions = parsedOptions.some(opt => opt.value === selectedValue);

            setIsOpen(false);
            setFocusedIndex(null);
            // ğŸš¨ [í•µì‹¬ ìˆ˜ì •]: custom-inputì˜ ì²« ë²ˆì§¸ ìì‹ ìš”ì†Œ(input)ì— í¬ì»¤ìŠ¤ ë°˜í™˜
            const inputElement = customInputRef.current?.firstChild as HTMLInputElement | undefined;
            if (inputElement) {
              inputElement.focus();
              setIsOpen(false);
            }

            if (!isValueMatchedInOptions) {
              // í˜„ì¬ ì…ë ¥ëœ ê°’ì´ ìœ íš¨í•œ ì˜µì…˜ ê°’ê³¼ ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ì´ˆê¸°í™” (ë¹ˆ ë¬¸ìì—´)
              setSelectedValue('');
              setSelectedId('');
            } else {
              // í˜„ì¬ ì…ë ¥ëœ ê°’ì´ ìœ íš¨í•œ ì˜µì…˜ ê°’ê³¼ ì¼ì¹˜í•˜ë©´ í•´ë‹¹ ê°’ì„ ìœ ì§€
              // ë‹¨, idë„ ì—…ë°ì´íŠ¸ë  ìˆ˜ ìˆë„ë¡ ë§¤ì¹­ë˜ëŠ” ì˜µì…˜ì„ ì°¾ì•„ idë¥¼ ì„¤ì •
              const matchedOption = parsedOptions.find(opt => opt.value === selectedValue);
              if (matchedOption) {
                setSelectedId(matchedOption.id);
              }
            }
          }
          // ì¼ë°˜ ë¬¸ì ì…ë ¥(e.key.length === 1)ì€ ì—¬ê¸°ì„œ ì²˜ë¦¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
          // ì´ëŠ” ë¸Œë¼ìš°ì €ì˜ ê¸°ë³¸ ë™ì‘(inputì— íƒ€ì´í•‘)ê³¼ handleChangeì— ìœ„ì„ë©ë‹ˆë‹¤.
        }

        if (e.key === 'Tab') {
          // ğŸš¨ [í•µì‹¬ ë¡œì§ í™•ì¸]: ìš”ì²­í•˜ì‹  ìœ íš¨ì„± ê²€ì‚¬ ë° ì´ˆê¸°í™”
          const isValueMatchedInOptions = parsedOptions.some(opt => opt.value === selectedValue);

          if (!isValueMatchedInOptions) {
            // í˜„ì¬ ì…ë ¥ëœ ê°’ì´ ìœ íš¨í•œ ì˜µì…˜ ê°’ê³¼ ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ì´ˆê¸°í™” (ë¹ˆ ë¬¸ìì—´)
            setSelectedValue('');
            setSelectedId('');
          } else {
            // í˜„ì¬ ì…ë ¥ëœ ê°’ì´ ìœ íš¨í•œ ì˜µì…˜ ê°’ê³¼ ì¼ì¹˜í•˜ë©´ í•´ë‹¹ ê°’ì„ ìœ ì§€
            const matchedOption = parsedOptions.find(opt => opt.value === selectedValue);
            if (matchedOption) {
              setSelectedId(matchedOption.id);
            }
          }

          if (isOpen) {
            setIsOpen(false);
          }
        }
      },

      [
        isOpen,
        filteredOptions,
        focusedIndex,
        handleSelect,
        selectedId,
        selectedValue,
        prevSelectedValue,
        setFocusedIndex,
        setIsOpen,
        setSelectedId,
        setSelectedValue,
        // ğŸš¨ [ì¶”ê°€] ê°’ ë³µì› ë¡œì§ì— ì‚¬ìš©ë¨
        parsedOptions,
      ],
    );
    // -----------------------------
    // focusedIndex ê¸°ë°˜ìœ¼ë¡œ activeDescendant ê³„ì‚°
    // -----------------------------
    const activeDescendant = useMemo(() => {
      // 1) í‚¤ë³´ë“œë¡œ í¬ì»¤ìŠ¤ëœ ì˜µì…˜ ìš°ì„  (filteredOptions ê¸°ì¤€)
      if (focusedIndex !== null && focusedIndex >= 0 && focusedIndex < filteredOptions.length) {
        const opt = filteredOptions[focusedIndex];

        if (opt) return `${opt.id}`;
      }

      // 2) í´ë¦­ìœ¼ë¡œ ì„ íƒëœ ì˜µì…˜
      if (selectedId) return `${selectedId}`;

      // 3) ì•„ë¬´ê²ƒë„ ì—†ìœ¼ë©´ ê³µë°±
      return '';
    }, [focusedIndex, filteredOptions, selectedId]);

    // -----------------------------
    // optionListChildrenì˜ DOM ìš”ì†Œ ì°¸ì¡°
    // -----------------------------
    const filteredOptionRefs = useRef<HTMLLIElement[]>([]); // í•„í„°ë§ëœ ì˜µì…˜ë§Œ ì°¸ì¡°

    const optionListChildrenWithRef = useMemo(() => {
      if (filteredOptions.length === 0) {
        // Empty state ì²˜ë¦¬
        return (
          <li key='empty-state' className='empty-state'>
            <Icon name='search-x' className='icon' strokeLinecap='round' strokeLinejoin='round' />
            <span className='title'>ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</span>
            <span className='desc'>ë‹¤ë¥¸ í‚¤ì›Œë“œë¡œ ë‹¤ì‹œ ê²€ìƒ‰í•´ ë³´ì„¸ìš”.</span>
          </li>
        );
      }

      // ë Œë”ë§ ì§ì „ì— refs ì´ˆê¸°í™”
      filteredOptionRefs.current = [];

      return filteredOptions.map((filteredOpt, filteredIndex) => {
        const originalOptionItem = optionItemArr.find(item => item.props.id === filteredOpt.id);
        if (!originalOptionItem) return null;

        // ref ì½œë°±ì„ ì‚¬ìš©í•˜ì—¬ filteredOptionRefsì— DOM ìš”ì†Œ ì €ì¥
        const setRef = (el: HTMLLIElement | null) => {
          if (el) {
            // OptionItemì´ HTMLLIElementë¥¼ ì°¸ì¡°í•œë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤.
            filteredOptionRefs.current[filteredIndex] = el;
          }
        };

        const selected = filteredOpt.id === selectedId;
        const focused = isOpen && focusedIndex === filteredIndex; // isOpen ì¡°ê±´ ì¶”ê°€í•˜ì—¬ ë‹«í˜”ì„ ë• í¬ì»¤ìŠ¤ í´ë˜ìŠ¤ ì œê±°

        // ğŸš¨ [í•µì‹¬ ìˆ˜ì • 2-1]: focusedì¼ ë•Œ 0, ì•„ë‹ˆë©´ -1ì„ ì „ë‹¬í•©ë‹ˆë‹¤.
        const itemTabIndex = focused ? 0 : -1;

        // [í•µì‹¬ ìˆ˜ì •: ref íƒ€ì… ë‹¨ì–¸]
        return React.cloneElement(
          originalOptionItem as React.ReactElement<OptionItemProps & { ref: typeof setRef }>,
          {
            key: filteredOpt.id, // React Key ì¶”ê°€
            id: filteredOpt.id,
            index: filteredIndex, // filteredIndexë¥¼ ì „ë‹¬
            tabIndex: itemTabIndex, // âœ… ë™ì ìœ¼ë¡œ ì „ë‹¬
            selected: selected,
            disabled: !!filteredOpt.disabled,
            value: filteredOpt.value,
            onSelect: handleSelect,
            // [ì œê±°] OptionItemì—ëŠ” onKeyDownì´ í•„ìš” ì—†ìŠµë‹ˆë‹¤.
            // onKeyDown: handleKeyDown,
            // ğŸš¨ [í•µì‹¬ ìˆ˜ì • 2-2]: OptionItemì— onKeyDownì„ ë‹¤ì‹œ ë°”ì¸ë”©í•©ë‹ˆë‹¤.
            // í¬ì»¤ìŠ¤ê°€ Inputì—ì„œ OptionItemìœ¼ë¡œ ì´ë™í•˜ë©´, OptionItemì´ í™”ì‚´í‘œ í‚¤ë¥¼ ì¡ì•„ì•¼ í•©ë‹ˆë‹¤.
            onKeyDown: handleKeyDown,
            ref: setRef,
            className: clsx(originalOptionItem.props.className, focused && 'focused-by-keyboard'),
          },
        );
      });
    }, [
      filteredOptions,
      optionItemArr,
      selectedId,
      focusedIndex,
      handleSelect,
      handleKeyDown,
      isOpen,
    ]);

    // -----------------------------
    // memoizedOptionList
    // -----------------------------
    const memoizedOptionList = useMemo(() => {
      if (!optionList) return null;

      return React.cloneElement(optionList, {
        selectedId: selectedId,
        onOptionSelect: handleSelect,
        className: optionList.props.className,
        children: optionListChildrenWithRef,
      });
    }, [optionList, optionListChildrenWithRef, selectedValue, handleSelect, isOpen]);

    // -----------------------------
    // í¬ì§€ì…˜ ì—…ë°ì´íŠ¸ ë° ì™¸ë¶€ í´ë¦­ ë‹«ê¸° (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
    // -----------------------------
    const updatePosition = useCallback(() => {
      const el = customInputRef.current ?? containerRef.current;
      if (!el) return null;
      const rect = el.getBoundingClientRect();
      return {
        top: rect.bottom + window.scrollY,
        left: rect.left + window.scrollX,
        width: rect.width,
      } as PortalPosition;
    }, []);

    useEffect(() => {
      const handleClickOutside = (event: MouseEvent) => {
        const target = event.target as Node | null;
        const insideContainer =
          containerRef.current && target && containerRef.current.contains(target);
        const insidePortal = portalRef.current && target && portalRef.current.contains(target);

        if (!insideContainer && !insidePortal) {
          setIsOpen(false);
          setFocusedIndex(null);

          // ğŸš¨ [ìˆ˜ì •]: ê°’ ë³µì› ë¡œì§ì„ ì—¬ê¸°ì„œ ì™„ì „íˆ ì œê±°í•©ë‹ˆë‹¤.
          // ë³µì› ë¡œì§ì€ Escape í‚¤ì™€ ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨ ì‹œì—ë§Œ ìˆ˜í–‰ë©ë‹ˆë‹¤.

          /* // [ì œê±° ëŒ€ìƒ] ì´ì „ ë³µì› ë¡œì§:
          const matchedOption = parsedOptions.find(opt => opt.value === selectedValue);
          if (!matchedOption || matchedOption.id !== selectedId) {
            setSelectedValue(prevSelectedValue || '');
            setSelectedId('');
          }
          */
        }
      };

      document.addEventListener('mousedown', handleClickOutside);
      return () => document.removeEventListener('mousedown', handleClickOutside);
    }, [parsedOptions, selectedValue, selectedId, prevSelectedValue]);

    // -----------------------------
    // í¬ì»¤ì‹± ì‹œ ìŠ¤í¬ë¡¤ ì´ë™ ë° ì½˜ì†” ë¡œê·¸ [ìˆ˜ì •]
    // -----------------------------
    // -----------------------------
    // í¬ì»¤ì‹± ì‹œ ìŠ¤í¬ë¡¤ ì´ë™ ë° í¬ì»¤ìŠ¤ ì´ë™ (Combobox.tsx)
    // -----------------------------
    useEffect(() => {
      if (isOpen && focusedIndex !== null) {
        const currentOption = filteredOptions[focusedIndex];
        if (!currentOption || currentOption.disabled) return;

        requestAnimationFrame(() => {
          const focusedEl = filteredOptionRefs.current[focusedIndex];
          if (focusedEl) {
            focusedEl.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
          }
        });
      }
    }, [focusedIndex, isOpen, filteredOptions]);
    // -----------------------------
    // í¬íƒˆ ìœ„ì¹˜ ê³„ì‚° ë° ë¦¬ìŠ¤ë„ˆ (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
    // -----------------------------
    useLayoutEffect(() => {
      if (!isOpen) {
        setPositioned(false);
        setPortalPos(null);
        return;
      }

      const pos = updatePosition();
      if (pos) {
        setPortalPos(pos);
        setPositioned(true);
      }
    }, [isOpen, updatePosition]);

    useEffect(() => {
      if (!isOpen) return;

      const handle = () => {
        const pos = updatePosition();
        if (pos) setPortalPos(pos);
      };

      window.addEventListener('resize', handle);
      window.addEventListener('scroll', handle, true);

      return () => {
        window.removeEventListener('resize', handle);
        window.removeEventListener('scroll', handle, true);
      };
    }, [isOpen, updatePosition]);

    // -----------------------------
    // ì„ íƒëœ ì˜µì…˜ìœ¼ë¡œ ì´ˆê¸° ìŠ¤í¬ë¡¤ ì´ë™ (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
    // -----------------------------
    useEffect(() => {
      if (!isOpen) {
        hasScrolledRef.current = false;
        return;
      }

      if (hasScrolledRef.current) return;

      const timeout = setTimeout(() => {
        const selectedIdxInFiltered = filteredOptions.findIndex(opt => opt.id === selectedId);
        if (selectedIdxInFiltered === -1) return;

        const selectedEl = filteredOptionRefs.current[selectedIdxInFiltered];
        if (selectedEl) {
          selectedEl.scrollIntoView({ block: 'nearest' });
          hasScrolledRef.current = true;
        }
      }, 0);

      return () => clearTimeout(timeout);
    }, [isOpen, selectedId, filteredOptions]);

    // -----------------------------
    // handleChange (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
    // -----------------------------
    const handleChange = useCallback(
      (e: React.ChangeEvent<HTMLInputElement>) => {
        const val = e.target.value;

        setSelectedValue(val);
        onValueChange?.(val);

        // ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ë©´ ë¬´ì¡°ê±´ ëª©ë¡ì„ ì—½ë‹ˆë‹¤.
        if (!isOpen) setIsOpen(true);

        // ğŸš¨ [í•µì‹¬ ì¶”ê°€]: íƒ€ì´í•‘ ì‹œì‘ ì‹œ ê¸°ì¡´ ì„ íƒ IDë¥¼ ë¬´ì¡°ê±´ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
        // ì´ëŠ” filteredOptions ë¡œì§ì´ ì„ íƒëœ IDì— ê¸°ë°˜í•˜ì—¬ í•„í„°ë§ì„ ìœ ì§€í•˜ëŠ” ê²ƒì„ ë°©ì§€í•©ë‹ˆë‹¤.
        setSelectedId('');

        // ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ë©´ ê¸°ì¡´ í¬ì»¤ì‹±ì„ ì´ˆê¸°í™”
        setFocusedIndex(null);
      },
      [onValueChange, isOpen],
    );

    useEffect(() => {
      // [ìˆ˜ì •] focusedIndexê°€ filteredOptionsì˜ ì¸ë±ìŠ¤ì´ë¯€ë¡œ, filteredOptionRefs ì‚¬ìš©
      if (isOpen && focusedIndex !== null) {
        const focusedEl = filteredOptionRefs.current[focusedIndex];
        if (focusedEl) {
          // ìŠ¤í¬ë¡¤ ì´ë™ì´ ì—¬ê¸°ì„œ ë°œìƒí•´ì•¼ í•©ë‹ˆë‹¤.
          focusedEl.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
      }
    }, [focusedIndex, isOpen, filteredOptions]); //

    // -----------------------------
    // ë Œë”ë§ (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
    // -----------------------------
    return (
      <div
        ref={containerRef}
        className={clsx(
          `${styles['combobox']} variant--${variant} color--${color} size--${size}`,
          className,
        )}
      >
        {/* ì»¤ìŠ¤í…€ ì…€ë ‰íŠ¸ íŠ¸ë¦¬ê±° */}
        <div ref={customInputRef} className='custom-input'>
          <input
            ref={ref}
            id={id}
            className='custom-input-text'
            tabIndex={disabled ? -1 : 0}
            disabled={disabled}
            value={selectedValue}
            placeholder={placeholder}
            type='text'
            role='combobox'
            aria-controls={ariaControls}
            aria-activedescendant={isOpen ? activeDescendant : ''}
            aria-expanded={isOpen}
            aria-haspopup='listbox'
            aria-labelledby={ariaLabelledBy}
            onFocus={() => {
              if (!disabled) {
                setPrevSelectedValue(selectedValue);
                setIsOpen(true);
              }
            }}
            onClick={() => {
              if (!isOpen) {
                setPrevSelectedValue(selectedValue);
                setIsOpen(true);
              }
            }}
            onBlur={handleBlur}
            onKeyDown={handleKeyDown}
            onChange={handleChange}
          />

          <IconButton
            color={color}
            size={size}
            variant='ghost'
            shape='rounded'
            className='adorned-end'
            type='button'
            icon={
              <Icon
                name='arrow-down'
                className='icon'
                strokeLinecap='round'
                strokeLinejoin='round'
              />
            }
            onClick={() => {
              setPrevSelectedValue(selectedValue);
              setIsOpen(prev => !prev);
              if (!isOpen) setFocusedIndex(null); // ë‹«í˜€ ìˆì„ ë•Œ ì—´ë©´ í¬ì»¤ìŠ¤ ì´ˆê¸°í™”
            }}
          />
        </div>

        {isOpen && positioned && portalPos && (
          <OptionListPortal isOpen={isOpen} position={portalPos} portalRef={portalRef}>
            {memoizedOptionList}
          </OptionListPortal>
        )}
      </div>
    );
  },
);

Combobox.displayName = 'Combobox';

export default Combobox;
